

	TO DO


		bookmark
			re-factor to PVDisplayObject
				exception level
				bubbling/propagation of exception level
					automatically bubble up all changes to parent 
					if parent property changes, bubble up to new parent
					propagation down should not be automatic, 
					but there should be a method for pushing a higher exepction level down to children
					(without triggering bubbling....)
					==> so the setter for exception level should not bubble, but there should be a separate method for "set_and_bubble"
				parent/child properties
				views
				IEditable interface???
				visibility property??? or does this still need to reside at the packet level???



			review protocol-specific H and G logic
				proper displayinfo logic - put in tests that will create exception level >0 for testing
				logic for exception level - set to 0 for known good cases
			then add filtering logic
				




		add IP6 support now???
		NO, NOT YET
			add struct for IP6, same operators as IP4
				store address as 2 longs (for space efficiency if/when we get to a point of having lots of IP6 objects)

			a class (or struct?) for IP, of which IP4 and IP6 are subclasses?
				structs do not support inheritance - what does this mean?



		augment displayinfo for RR's - useful in debugging when viewing Locals



		add general logic for filtering view based on "exception level"
			exception level is determined at the header, packet and group level
			show exception level in displayinfo if > 0
			packet exception level is max (levels of its headers, level of packet itself)
			group exception level is based on the group
			if group has except level >0, show all packets in group
			==> use Packet.parent property to determine Packet.Visible (rename the "FilterMatched" property to "Visible")






		augment displayinfo for DNSH
			what are the "typical" forms
				query
				"typical" answer - one line summary should just show the first IP4 returned
					start with simple definition of "normal" fingerprint, can add more as we observe
						"normal" seems to have these characteristics: (at least for traffic between a LAN client and the local DNS server on that LAN)
							two packets, one query, one response
							response RRs include only
								query packet, query section has only one RR
								response packet
									query section has only one RR
									answer section - A RRs and CNAME RRs
										CNAME records provide CNAME for name in prior RR
									ns authority section - zero or more NS RR, relating to the domain in the query
									additional records section - A or AAAA records for the nameservers in the ns auth section
				"unusual" - neither of the first two
		augment display info for DNSG - flag types other than the typical Q&A
			typical group characteristics
				one query with one RR
				one answer that is "typical" (see above)


				

		data structure for ip-dns map
			what do we want it to do?
				allow searches of all-domains-for-a-given-ip and all-ips-for-a-given-domain
				allow efficient filtering based on a domain
					e.g., i want to say "include/exclude *.domain.com"
						==> need to rapidly look up whether an ip4 or ip6 relates to *.domain.com
							==> rapid, high volume lookups will be keyed by ip4/ip6
								==> dict keyed by ip
									==> need generic class for ip address, of which ip4 and ip6 are sub-classes





		add command to append a new capture file to ones already loaded

		enhance dns header one-line display info per notes below

		enable feeding of ip-dns map

		enable gui display of ip-dns map

		make gui highlight cases where multiple IPs for same domain
		also highlight cases where mutiple domains for same IP

		add ip-dns map info to IP4 tooltip display

		enable storage and retrieval of map - so it can grow over sessions




		dns
			enhancements
				additional info in DNSH pvdisplayinfo
					abbreviated info on packet sufficient to identify
					"usual" and ""unusual" packet sequences
						what is that?
							dns type (qustion or response)
							dns flags - recursion at least
							list of rr types
							no rrdata

				additional information in displayinfo for RRs
					type (number and name)
					class
					TTL
					RDATA - formatted accordingly for each type
				make filter for dns values i haven't leanred how to handle
					class other than internet


				throw dialog after packet file load if un-grocked dns records were loaded
					maintain a dictionary of <protocol, List<string>>
					header parsers can add exception info and pvdisplay info to list
					when file load done, open non-modal window if the dict is not empty
					dict window allows close and simple clear of the dictionary

					set some kind of "exception flag" that gets passed up the header parse stack
					and puts up a message box
				
				rdns crawler - read tcp/ip illustrated vol1, starting in section 11.5.6.4 (page 516)


			must also handle dns over tcp see rfc 5966
			set up dns server on windows?  or on pfsense?
				can it make outbound dns requests encrypted?
				can it make outbound dns requests go to some non-google, non-verizon server?





	ip-dn mapping
		data elements - list of idmtableitem
			ip
			domains - list of idmdomain
				domain name
				time first observed
				time last observed
				obtained from RDNS or from reading DNS packets?
				list of dns servers that provided this name
				other information TBD that is worth capturing

		operations
			rdns update
			"contribute ip" - method called by ip4 header constructor, to add the ip4 address to the table
			"contribute dns" - method called by dns header reader, to add its information
				IMPLEMENT BY TRACING DNS HEADER READING CODE
				DISCOVER VARIATIONS IN WHAT KINDS OF DNS INFO COMES IN
					WHILE AT HOME
					WHILE IN WORK NETWORK
					WHILE ON IPHONE NETWORK
			file merge - merges info within records
			scan for noteworthy situations
				situations to flag
					ip for a domain changes over time (don't know how much of an anomaly this is, but anomaly or not, i want to observe ip addresses changing.....)
					ip addresses with no known domain name (use RDNS either on background thread or trigggered manually)
		validator/converters
			add dns entries to ip tostringalts
			dlist
				main display is list of domains
				tooltip shows expanded info on each
				


	datetime converters seem busted


			

	window layout
		next steps:
			save window divider state
			implement ip4<->dns map
			implement code to populate the dns map when reading packet files
			implement code to show domain names in place of ips (with check box for show domain, and databinding just like aliases)


	workflow
		scan files (one or multiple)
			select list of files
			for each file, parse headers far enough to get the ether, ip and dns information
				purpose is to 
					(1) build tabulation of 
							internal host | wan  host | protocol | packet count | byte count | ealiest time | latest time
								do this by building dictionary keyed by sourceip, destip, protocol, then updating counts and time for each packet
								then merge entries where src/dest == dest/src
					(2) add to dns history db - see below

		show tabulation from scan - idea is user will change filters based on this

		load files
			enter filters (perhaps based on the scan)
			select list of files
			for each file, load packets that pass the filter - keep loading all files into memory

		save packets in memory as a pcap file

		load filtered and save as a single operation - can be time consuming, want to be able to launch and walk away

	dns history database
		data structure:
			dictionary
				key: ip address
				value: list of dns observations
					item is a domain name and time of earliest and latest observation
		data is populated by dns header reader
		need viewer
		file management
			similar to filters
				load and save
				"merge" i.e. union one or more files into data in memory
				mainwindow remembers last file opened
		may add reverse dns lookup background thread at some point









	test datetime filters - data entry not working?


	other types of filters
		packet sequence number (simply the order in the file)
		protocol
		grouptype
			when would/could this be applied?
				group type is determined when packets load, but in a separate pass after all the packets are loaded
				want to have filters apply during packet load, to avoid having to do expensive gropu processing on bulks of packets that will be discarded based on simple mac or ip filters
				maybe ignore grouptype filters in the packet load pass, then apply the filters again during the group determinatino pass?
				add "GroupType" property to Packet - set to null until group determination pass is done


	window state management
		when load packet file, close packet viewer
		when apply filter, close packet viewer
		when close packet viewer, make it re-open when another packet is selected


	enhance load/save behavior
		append filter

	enable quick ways to add filters based on packets shown
		e.g. specialized label for ip4 address
			tooltip that shows the alias/raw version
			right-click command to add filteritem based on this item
		add up/down buttons on filteritems that can make them traverse filters - action would be to right-click an ip4, then use up/down buttons to move into place in filter list






	FIGURE OUT HOW TO HANDLE THE PACKET VIEWER WINDOW CLOSING - EITHER PREVENT IT, OR LET THE MAINWINDOW KNOW 


	packet viewer
		can make copy, which becomes another window, that will not be linked to main window any more
		color code portions of packet by iterating over headers 

	tcp stream view
		right click on tcp group opens separate window with stream view
		buttons to toggle stream 1 and stream 2
		button to toggle plain text view vs. hex dump view
		text box to indicate number of bytes to process from each stream (default 1000)
		window header to indicate
			src and dest ip4 and port
			total numbers of packest and bytes

	main window
		allow toggle between view by group and view by packet
			view by packet should be a datagrid, which can be sorted by sequence number, time, protocol, port, etc
			view by group should also be datagrid, which can be sorted by group type, time of first or last packet, etc.





	add http/https
	group tcp, http, https


	enhance filtering logic
		first finish up mac and ip4 based filtering, just to cut down size of files we work on
		then add excl/incl lists for other protocols
			arp
			icmp
			dns
			udp
			tcp
			http/https
		make the list be representalbe as a simple text file, so they can be exhanged with the linux c-based packet capture tool



perf analysis - is grouping logic still the hot spot?
	can just test by commenting out various groupings


augment headerdisplayinfo properties to highlight exceptional cases (errors, malformed data, truncated, incomplete groups, etc)
highlight message types, codes, options etc that we have not handled (yet)

additional cases to handle

	dns over tcp (see rfc 5966)
	dns malformed message types
		names too long (>255 per rfc 1035, or is there a higher limit now?)
		compressed name length fields with first two bits 10 or 01 (reserved per rfc 1035 section 4.1.4)
	dns query types not supported
	dns RR types not supported

	tcp incomplete sequences (missing start, missing end, missing in middle)
	http incomplete sequences (tcp incomplete, no dns source)
			
	tcp - variable length head and tail byte arrays



	add handling for IP4 fragments		

	handle IP4 "options" field

	look for comments in code







    // tcp group extensions
    //      profiling information
    //          each group should have a flag indicating whether it has been profiled yet
    //          do not profile until one of the profile properties is accessed
    //          profile items:
    //              flag no missing bytes in sequence numbering
    //              flag proper setup
    //              flag proper teardown
    //              flag RST termination - termination with a single RST is not strictly kosher but typical of browser behavior, per some web page
    //              flag RST followed by other traffic - this could be more problemmatic
    //              nunber of duplicate packets present
    //              number of packets data received out of order
    //              number of keep alives used
    //              duratin of keep alives
    //              number of retransmissions
    //              other characteristics that may signal problems
    // 


	ipdnsmapper as separate solution
		prompt to open existing file at startup
		save file to disk after each pass through source packet files
		rename packet files after processing, not move them
		display - tree, sorted by ip4 (use a "view" to sort?)
		display - button to open separate dialog to search for a domain name
						- accept wildcards (regular expressions?)
						- return list of ips
		put dn lookup on separate thread
	collect list of unhandled cases







stages of loading a capture file

	0) load raw packets from file, parse all headers possible

	1) if parsing an ip header finds that this is a fragment, group with other ip datagram fragments
		- this is a special case because the result is treated as a single packet downstream
		- how to test?  --> use sample from Practical Packet Analysis
		- maybe this should happen automatically on reading the file
			- create dictionary of pointers to "agg packets" keyed by ip sequence number
			- the "agg packet" is a packet with the layer 2 and ip header information populated so it will look like a single packet downstream
			- for each new fragment, add the data to its "agg packet" (expanding the data array if necessary)
			- for each "agg packet" keep a list of "extents" which are pairs of (offset,length)
				- detect duplicate fragments
				- detect missing fragments
					- handle case where never see the fragment with MF=0, so don't know the full length
			- when a datagram is re-assembled, remove from dictionary, parse higher layer headers, and add to main packet list using max timestamp
			- report missing fragments 
		- make the aggregated datagram appear to be a single packet, using max of timestamps of fragments (that would be the time it is available to upstream)
		- flag to indicate whether missing fragments
		- pointer to list of raw packets (or drop the raw fragments??)


	2) group based on protocol

			- each protocol header has a method for incorporating a new packet into its groups
			- for each packet, look for the highest layer protocol and try the associated grouping function
				- eventually will add user options to control which protocols to group for
				- if that function returns false (indicating packet not accepted into group), notify user - this shoudl never happen

			- protocols that should be mutually exclusive of each others within same layer i.e., a packet belongs to one and only one of these protocols
			- this pass will result in a list of groups that are individual "conversations", e.g., an arp handshake, a udp sende/receiver pair or a tcp session
			- plus a list of ungrouped packets (if nothing else, due to protocols not handled yet)

			- properties of group list members:
				- "group protocol" - the protocol that is the basis for defining this group
					- from protocols enum 
					- but with another item for "ungrouped", to indicate ungrouped packets
				- group header
					- same type as regular protocol header, but only populated with the values that determine group membership
					- or null for "ungrouped"
				- first/last timestamp
				- completeness flag (? or shoudl this just be the result of a method?)
				- list of members (references to other groups or individual packets)


	2.5) groups within groups - not clear yet whether this will be necessary or useful


	3) have methods to test each group for 
			- completeness
			- corruption
			- anomalies












workflow, ui and backing data

	1) make loading a file a distinct operation, which parses all packets and puts them into a single list (and applies quickfilter, which will create a second list temporarily while i test it)
	2) application of packet sets creates a set of pointers into the master packet list
	3) doing the "group into convos" operation creates a list of convos *within each packet set*
		3.1) testing for convo membership is a method within each headerfield class
		3.2) (can make this an option later, initially we can just always group on all protocols that support it) user specifies which protocols to do convo testing for
		3.3) apply convo testing for lower level protocols first - so, say, IP4 gets defragged first, then tcp fragments get combined
			3.3.1) so that means each there will be a separate pass through the packets for each layer
				3.3.1.1) 
			3.3.2) 
		3.4) a convo is
			3.4.1) a special case of a packet
			3.4.2) one (or more??) of the packet header members will be populated with the common header information
			3.4.3) instead of data, there will be a list of pointers to member packets (Which can themselves be convos)
	4) display
		4.1) tree view of groups
		4.2) datagrid of groups
		4.3) datagrid of packets
		4.4) datagrid columns will be a select few columsn we will want to use for sorting, e.g., timestamps, macs, ip addresses and protocols
		4.5) the properties backing the DG columns will be properties at the packet level - protcol constructors will populate these packet-level properties when they construct the header	













git - how to roll back????
    - how to open a branch to an earlier version so i can just look at how it used to work


timestamp value converter for display

hex data view for data portion of each packet (as detail view in datagrid?)

tool to summarize column of packet data grid with counts (sort by count, or by item value)
	difficulty is how to extract a list of the values of a certain field from setlist.sets.pkts
	the datagrid column can give the binding, which contains the headerfield path as a string
	is there a method that will automatically get the values in a datagrid column (try internet search - was not online when tried this)
	can reflection use the path string to access the properties of pkts?  (probably yes, but is it fast enough - see p. 781 of c# in a nutshell)


aggregate IP4 fragments
	handle dumps that do not include all fragments

add support for more protocols
	tcp
	udp
	icmp
	icmp router discovery (rfc 1256 - is this still current?)
	icmp other extensions

group "conversations"
	examples of conversations:
		arp request and response
		tcp session

	definition of a conversation:
		-
		-

	how a conversation should be presented in gui
		- allow for expand/collapse??

	how to handle incomplete conversation





remove (or comment out) facility to view packets excluded via quickfilter
	separate datagrid
	qfexcluded packet set in mainwindow
	logic in file read method that puts an "excluded" packet into separate packet set


handle IP4 "options" field


quickfilters
	test performance - if too slow, try optimizing by
		ordering filters
		structuring into dictionaries (one dict for each mask value) using comparevalue as the key

	maybe also add other criteria, like ether type/len field (to exclude ipv6 noise, for example)

	dialog improvements
		checkboxes to toggle aliasing of mac/ip addresses
		drag and drop
		add/delete row respect multi selections






